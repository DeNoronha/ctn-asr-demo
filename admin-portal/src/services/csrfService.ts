/**
 * CSRF Token Service (SEC-004)
 * Implements double-submit cookie pattern for CSRF protection
 *
 * UPDATED: Server-generated cryptographic tokens
 * The backend API now generates cryptographically secure CSRF tokens (256-bit)
 * and sets them via Set-Cookie header on successful authentication.
 *
 * How it works:
 * 1. Backend generates cryptographic token (crypto.randomBytes(32))
 * 2. Backend sets XSRF-TOKEN cookie via Set-Cookie header
 * 3. Frontend reads token from cookie
 * 4. Frontend includes token in X-CSRF-Token header
 * 5. Backend validates cookie matches header using constant-time comparison
 *
 * This prevents CSRF attacks because:
 * - Attacker cannot read cookie from different origin (SameSite=Strict)
 * - Attacker cannot set custom headers on cross-origin requests
 * - Tokens are cryptographically random (cannot be predicted)
 * - Tokens expire after 30 minutes (rotated on auth refresh)
 *
 * Security improvements over old implementation:
 * - Uses crypto.randomBytes() instead of UUID (256 bits vs ~122 bits entropy)
 * - Server-controlled token generation (frontend cannot be manipulated)
 * - Constant-time comparison prevents timing attacks
 * - Token expiration and rotation
 */

const CSRF_COOKIE_NAME = 'XSRF-TOKEN';
const CSRF_HEADER_NAME = 'X-CSRF-Token';

/**
 * CSRF Service
 * Manages CSRF token lifecycle (read, clear)
 * Note: Token generation is now handled by the backend
 */
export class CsrfService {
  /**
   * DEPRECATED: Token generation is now handled by backend
   * This method is kept for backward compatibility but does nothing.
   * The backend automatically generates and sets CSRF tokens on authentication.
   *
   * @deprecated Backend generates tokens automatically
   * @returns null
   */
  generateToken(): string | null {
    console.warn(
      '[CSRF Service] generateToken() is deprecated. ' +
        'CSRF tokens are now generated by the backend and set via Set-Cookie header.'
    );
    return null;
  }

  /**
   * Get current CSRF token from cookie
   * Used to include in request headers
   *
   * @returns CSRF token or null if not found
   */
  getToken(): string | null {
    const cookies = document.cookie.split(';');
    for (const cookie of cookies) {
      const [name, value] = cookie.trim().split('=');
      if (name === CSRF_COOKIE_NAME) {
        return value;
      }
    }
    return null;
  }

  /**
   * Remove CSRF token from cookie
   * Called on logout
   */
  clearToken(): void {
    document.cookie = `${CSRF_COOKIE_NAME}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; Path=/; Secure; SameSite=Strict`;
  }

  /**
   * Get the header name for CSRF token
   * Used by axios interceptor
   *
   * @returns Header name for CSRF token
   */
  getHeaderName(): string {
    return CSRF_HEADER_NAME;
  }

  /**
   * Get the cookie name for CSRF token
   * Used for backend validation
   *
   * @returns Cookie name for CSRF token
   */
  getCookieName(): string {
    return CSRF_COOKIE_NAME;
  }
}

// Export singleton instance
export const csrfService = new CsrfService();
